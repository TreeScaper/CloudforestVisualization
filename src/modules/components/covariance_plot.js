import { scaleQuantize } from "d3-scale";
import { forceSimulation, forceCollide, forceManyBody, forceLink, forceX, forceY, forceCenter } from "d3-force";
import { create, select } from "d3-selection";
import { drag } from "d3-drag";
import { mean, max, ascending } from "d3-array";
import { hierarchy, cluster, tree } from "d3-hierarchy";
import { scaleLinear, eas } from "d3-scale";

import { roundedRect } from "../utilities/support_funcs";
import { removeChildNodes, cleanExistingPlot, htmlToElement } from "../utilities/html_templates";
import { css_colors } from "../utilities/colors";
import { build_event } from "../utilities/support_funcs";
import { parse_taxa_partitions } from "../components/bipartition_data.js";
import { get_root } from "./phylogram_page.js";
import { newick_parse } from "tree_data_parsing"
import { CloudForestPlot } from "cloudforest_plot.js";

class GraphData {
    "nodes": [],
    // Only links that are displayed. Links with a covariance below a certain threshold
    // will not be in this list.
    "displayed_links": [],
    "all_links": []
}

class CovariancePlot extends CloudForestPlot {

    static canvas_plot_element_id = 'covariance-canvas';

    // Radius for tree nodes
    static tree_node_r = 5;
    
    // Radius for covariance plot nodes
    static cov_node_r = 5;
    static highlight_cov_node_r = 7;

    max_covariance = 0;
    taxa_array = [];
    part_taxa = {};
    canvas = undefined;
    link_scale = undefined;
    cd_groups = undefined;

    // Representation of covariance network
    let filtered_adjacency_list = undefined;

    // Number of trees for phylogram
    num_trees = 0;

    constructor(plot, controls, metadata) {
        super(plot, controls, metadata);
        this.graph_data = new GraphData();

        // Scale for calculating width of covariance network link on canvas.
        link_scale = d3.scaleQuantize()
                .domain([0, max_covariance])
                .range([.5, 2, 5, 10]);
    }

    /**
     * Create data structure with entry for each element, representing a link in the covariance graph,
     * of the covariance matrix.
     *
     * @param {[][]} m The covariance matrix data.
     */
    parse_covariance(m) {
        m.forEach((arr, idx) => {
    
            //Removing superflous empty value at end of each array
            arr.filter(v => v.length > 1).forEach((val, i) => {
                if (i != idx) {
                    let o = {
                        "source": String(idx),
                        "target": String(i),
                        "value": Number(val.trim())
                    }
                    this.graph_data.displayed_links.push(o);
                    this.graph_data.all_links.push(o);
                    if (Math.abs((Number(val.trim()))) > max_covariance) {
                        this.max_covariance = Math.abs(Number(val.trim()));
                    }
                }
            });
        });
    }

    /**
     * Parses the TreeScaper bipartition matrix producing a BP -> tree object.
     * Key: bipartition number; Value: array of trees where the bipartition is present.
     * @param {[][]} m - Bipartition Matrix generated by TreeScaper
     */
    parse_bipartition_cov(m) {
        let b = {};
        m.forEach(r => {
            //let bp_name = String(Number(r[0].trim()) + 1);
            let bp_name = String(Number(r[0].trim()));
            if (!(bp_name in b)) {
                b[bp_name] = [];
            }
            b[bp_name].push(r[1]);
        });
    
        Object.keys(b).forEach(k => {
            let o = {
                "id": k,
                "num_trees": b[k].length
            };
            this.graph_data.nodes.push(o);
            if (b[k].length > this.num_trees) {
                this.num_trees = b[k].length;
            }
        });
    }

    /**
     * Parses taxa into array
     * @param {Object} d - Raw file data
     */
    parse_taxa_array(d) {
        let arr = d.split('\n')
        arr.pop();
        arr.shift();
        arr.forEach(e => {
            this.taxa_array.push(e.split(',')[1].trim());
        });
    }

    /**
     * Parse the bipartion count file
     *
     *  0, 000000000000000010011000000, 11
        1, 001111111111000000000100000, 10
        2, 001100001111111111111011110, 1
        3, 000011111111111100000011110, 1
     *
     * @param {*} m - bipartition count file. An array of strings
     */
    parse_taxa_partitions(m) {
        let part_taxa = {};
        m.forEach(line => {
            let arr = line[0].split(' ');
            let bp = Number(arr[0]) + 1;
            part_taxa[bp] = [];
            arr[1].trim().split("").forEach((e, idx) => {
                if (e === "1") {
                    part_taxa[bp].push(this.taxa_array[idx]);
                }
            });
        });
        return part_taxa;
    }

    build_controls() {
        let pcc = document.getElementById(this.controls);
        pcc.append(htmlToElement(`<div class="field has-addons">
            <h4>Remove Links Below&nbsp;</h4>
            <div class="control">
                <input type="number" id="link-strength" min="1" max="100" value="50" size="4"></input>
            </div >
            <h4>% of Maximum Magnitude</h4>
            </div > `));
        document.getElementById("link-strength").addEventListener("input", event => {
            let thresh = Number(document.getElementById("link-strength").value);
            update_links(thresh);
            draw_covariance();
        });
    }

    /**
     * Creates HTML displaying information on selected node.
     *
     * @param {Object} p Profiled node data
     */
    build_metadata() {
        const elm = document.getElementById(this.metadata);
        //elm.classList.add("box");
        let e_string = `
        <h4>Partition ${p.id}</h4>
        <table class="table"><thead><tr>
        <th>Tree Count</th><th># Pos. Cova</th><th>Mean Pos. Cova</th><th>Max Pos. Cova</th>
        <th># Neg. Cova</th><th>Mean Neg. Cova</th><th>Max Neg. Cova</th></tr></thead>
        <tbody>
        <td>${p.num_trees}</td><td>${p.num_pos_cova}</td><td>${p.mean_pos_cova.toPrecision(4)}</td><td>${p.max_pos_cova.toPrecision(4)}</td>
        <td>${p.num_neg_cova}</td><td>${p.mean_neg_cova.toPrecision(4)}</td><td>${p.max_neg_cova.toPrecision(4)}</td>
        </tbody>
        </table>
        `
        elm.innerHTML = e_string;
    }

    /**
     * Draw a single node in covariance network.
     *
     * @param {Object} d Node object.
     */
    drawNode(d) {
        let canvas = document.getElementById("covariance-canvas");
        let ctx = canvas.getContext('2d');
        ctx.beginPath();
        ctx.moveTo(d.x, d.y);
        let r = is_highlighted_bipartition(d.id) ? highlight_cov_node_r : cov_node_r;
        ctx.arc(d.x, d.y, r, 0, Math.PI * 2);
        ctx.globalAlpha = set_node_alpha(d);
        ctx.fillStyle = set_fillstyle(d);
        ctx.fill();
    }
    
    
    /**
     * Sets alpha for covariance network link in proportion to its relation to the maximum magnitude for all links.
     *
     * @param {Object} l Link
     */
    static set_link_alpha(l) {
        let alpha = 1 - ((max_covariance - Math.abs(l.value)) / max_covariance);
        return alpha;
    }
    
    /**
     * Sets alpha for covariance network node in proportion to the frequency of its occurence in the corresponding tree set.
     *
     * @param {Object} d Node
     */
    static set_node_alpha(d) {
        if (is_highlighted_bipartition(d.id)) {
            return 1.0;
        }
        let alpha_pct = (d.num_trees / this.num_trees);
        if (alpha_pct < 0.1) { alpha_pct = 0.1 };
        if (cd_groups) {
            return 1.0;
        } else {
            return alpha_pct;
        }
    }
    
    /**
     * Sets color for covariance network node.
     *
     * @param {Object} d Node object
     */
    static set_fillstyle(d) {
    
        // Neon green if highlighted.
        // DEV
        //if (is_highlighted_bipartition(d.id)) {
        //    return "rgba(57, 255, 20, 1)";
        //}
    
        // If we have corresponding CD data, use those colors.
        if (cd_groups) {
            try {
                let x = cd_groups[Number(d.id)].color;
                return x;
            } catch (error) {
                return "white";
            }
        } else {
            return "black";
        }
    }

    /**
     * Draw a single link in covariance network.
     *
     * @param {Object} l Link object.
     */
    drawLink(l, ctx) {
        if (l.value < 0) {
            ctx.strokeStyle = "red";
        } else if (l.value > 0) {
            ctx.strokeStyle = "blue";
        } else {
            ctx.strokeStyle = "lime";
            ctx.lineDashOffset = 1;
        }
        ctx.beginPath();
        ctx.globalAlpha = set_link_alpha(l);
        ctx.lineWidth = link_scale(Math.abs(l.value)) / 5;
        ctx.moveTo(l.source.x, l.source.y);
        ctx.lineTo(l.target.x, l.target.y);
        ctx.stroke();
    }

    /**
     * Redraws covariance network on existing covariance-canvas element.
     *
     * DEV renamed from redraw_full_cov_graph
     */
    draw_covariance() {
            let ctx = this.canvas.getContext('2d');
            ctx.beginPath();
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            set_background('covariance-canvas');
            ctx.globalAlpha = 1.0;
            for (const l of graph_data.displayed_links) {
                drawLink(l, ctx);
            }
            for (const l of graph_data.nodes) {
                drawNode(l, ctx);
            }
    }

    /**
     * Create an adjacency list from the covariance matrix.
     */
    build_matrix() {
        filtered_adjacency_list = {}; //Matrix as adjacency list
        graph_data.nodes.forEach(n => {
            filtered_adjacency_list[n.id] = [];
        });
        graph_data.displayed_links.forEach(l => {
            filtered_adjacency_list[l.source.id].push({ id: l.target.id, covariance: l.value });
        });
    }
    
    
    /*
     * Populates graph_data.displayed_links by selecting only links above a certain threshold.
     * These are the links that are actually drawn on the visualization. The user may adjust this threshold
     * in the interface, and the links are redrawn.
     *
     * This function also rebuilds the filtered_adjacency_list
     *
     * @param {number} link_threshold The threshold in percentage of maximum covariance
     */
    update_links(link_threshold) {
        let link_strength_thresh = link_threshold / 100.0;
        let edited_links = [];
        graph_data.all_links.forEach(obj => {
            if (Math.abs(obj.value) >= (link_strength_thresh * max_covariance)) {
                edited_links.push(obj);
            }
        });
        graph_data.displayed_links = edited_links;
        build_matrix();
    }

    draw() {
        // Remove child-nodes of cov-plot and recreate canvas as child
        removeChildNodes(this.plot);

        let doc_width = document.getElementById(this.plot).clientWidth;
        let width = Math.floor((doc_width - (.15 * doc_width)) / 100) * 100;
        let height = width;

        // Create new canvas
        this.canvas = document.createElement('canvas');

        // Set canvas attributes
        canvas.setAttribute('id', canvas_plot_element_id)
        canvas.setAttribute("width", width);
        canvas.setAttribute("height", height);

        // Add canvas to document
        document.getElementById(this.plot).append(canvas);

        let ctx = canvas.getContext('2d'),

        // Tick function that redraws the graph and tooltip
        let tick = function () {
            draw_covariance(canvas);
            if (tooltip !== null) {
                draw_tooltip();
            }
        }

        // d3 library that simulates forces acting between and on the graph nodes
        let simulation = d3.forceSimulation(graph_data.nodes)
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force("x", d3.forceX(width / 2))
            .force("y", d3.forceY(height / 2))
            .force("charge", d3.forceManyBody().strength(-20))
            .force("link", d3.forceLink()
                .id(function (d) { return d.id; }).distance(width / 3));

        // Assign our function to the simulation tick
        simulation.on("tick", () => {
            tick();
        });

        // Add links to simulation
        simulation.force("link")
            .links(graph_data.all_links);

        // This populates the displayed_links field with only links above a certain threshold.
        update_links(50);

        // Called when user moves their mouse over the canvas. This allows for the inspecting and selecting
        // of specific bipartitions in the network.
        // DEV Commented out at this stage of development
        // canvas.addEventListener("mousemove", function(e) {

        //     // Get coordinates of the canvas element in the browser page.
        //     let canvas_rect = canvas.getBoundingClientRect();

        //     // This represents the X and Y in relation to the canvas element.
        //     let x = e.clientX - canvas_rect.left, y = e.clientY - canvas_rect.top;

        //     // Will be set to a bipartition that is found to be under the user's mouse.
        //     let found_bipartition = null;

        //     // Iterate through each node.
        //     for (const d of graph_data.nodes) {

        //         // Find distance between user's mouse and center of the node.
        //         let dist = Math.sqrt(Math.pow(x - d.x, 2) + Math.pow(y - d.y, 2));

        //         // If that distance is less than the node radius, the user's mouse is found to be within the node drawing,
        //         // Use the slightly larger highlighted radius for an extra margin in which the node becomes highlighted.
        //         if (dist < highlight_cov_node_r) {

        //             // Get the set of taxa representing the moused over bipartition.
        //             let bipartition_set = new Set(parsed_bipartition_taxa[d.id]);

        //             // Iterate through links in the phylogram
        //             for (const t of tree_links) {

        //                 // For each phylogram link, representing a bipartition, find the associated taxa.
        //                 let leaf_names = [];
        //                 for (const leaf of t.link.target.leaves()) {
        //                     leaf_names.push(leaf.data.name);
        //                 }
        //                 let leaves_set = new Set(leaf_names);

        //                 // If the taxa both from the covariance network bipartition (node), and the phylogram bipartition (link) are equal
        //                 // they are the same bipartition. Select the found link as the current_link, which means it will be highlighted.
        //                 if (set_equality(leaves_set, bipartition_set)) {
        //                     current_link = t;
        //                 }
        //             }

        //             // Node the bipartition we found under the mouse and break.
        //             found_bipartition = d.id;
        //             break;
        //         }
        //     }

        //     // If we found a bipartition under the mouse, set the current_bipartition, redraw both phylogram and covariance network, and the tooltip.
        //     if (found_bipartition !== null) {
        //         if (current_bipartition !== found_bipartition) {
        //             current_bipartition = found_bipartition;
        //         }
        //         draw_covariance();
        //         draw_phylogram();
        //         tooltip = {
        //             ctx: ctx,
        //             x: x,
        //             y: y,
        //             text: `Bipartition ${found_bipartition}`
        //         };
        //         draw_tooltip();

        //     // If we found nothing, and there was in the previous mouseover event a bipartition under the mouse (the mouse is moving out of a node),
        //     // clear tooltip, current link and bipartition, and redraw visualization.
        //     } else {
        //         tooltip = null;
        //         if (current_bipartition !== null) {
        //             current_link = null;
        //             current_bipartition = null;
        //             draw_covariance();
        //             draw_phylogram();
        //         }
        //     }
        // });

        // // When a bipartition node is clicked, its added to the list of selected bipartitions and both it and its corresponding bipartition in phylogram (if it
        // // exists) are highlighted until another node is selected. Holding shift allows for the selection, and deselecting, of multiple nodes.
        // canvas.addEventListener("click", function(e) {
        //     if (current_bipartition != null) {
        //         if (!selected_bipartitions.includes(current_bipartition)){
        //             if (e.shiftKey) {
        //                 selected_bipartitions.push(current_bipartition);
        //                 selected_links.push(current_link);
        //             } else {
        //                 selected_bipartitions = [current_bipartition];
        //                 selected_links = [current_link];
        //             }
        //         } else {
        //             selected_bipartitions = selected_bipartitions.filter(b => b != current_bipartition);
        //             selected_links = selected_links.filter(b => b != current_link);
        //         }
        //     }
        // });


    }
}
