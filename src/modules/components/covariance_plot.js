import { scaleQuantize } from "d3-scale";
import { forceSimulation, forceCollide, forceManyBody, forceLink, forceX, forceY, forceCenter } from "d3-force";
import { create, select } from "d3-selection";
import { drag } from "d3-drag";
import { mean, max, ascending, extent } from "d3-array";
import { hierarchy, cluster, tree } from "d3-hierarchy";
import { scaleLinear, eas } from "d3-scale";

import { roundedRect } from "../utilities/support_funcs";
import { removeChildNodes, cleanExistingPlot, htmlToElement } from "../utilities/html_templates";
import { css_colors } from "../utilities/colors";
import { build_event, set_background } from "../utilities/support_funcs";
import { CloudForestPlot } from "./cloudforest_plot.js";

const getEvent = () => event; // This is necessary when using webpack >> https://github.com/d3/d3-zoom/issues/32
const d3 = Object.assign(
    {
        mean,
        max,
        select,
        event,
        extent,
        getEvent,
        drag,
        hierarchy,
        ascending,
        scaleLinear,
        create,
        scaleQuantize,
        forceSimulation,
        forceCollide,
        forceManyBody,
        forceLink,
        forceX,
        forceY,
        forceCenter
    }
);


class GraphData {
    "nodes" = [];
    // Only links that are displayed. Links with a covariance below a certain threshold
    // will not be in this list.
    "displayed_links" = [];
    "all_links" = [];
}

class CovariancePlot extends CloudForestPlot {

    static canvas_plot_element_id = 'covariance-canvas';

    // Radius for covariance plot nodes
    static cov_node_r = 12;
    static highlight_cov_node_r = 14;
    static cov_node_charge_force = -30;

    node_radius_scale = undefined;
    max_covariance = 0;
    taxa_array = [];
    canvas = undefined;
    link_scale = undefined;
    cd_groups = undefined;
    maximum_magnitude = undefined;
    scale = 1;
    simulation = undefined;

    // Representation of covariance network
    filtered_adjacency_list = undefined;

    selected_bipartitions = [];
    current_bipartition = null;

    // Number of trees for phylogram
    num_trees = 0;

    constructor(plot, controls, metadata) {
        super(plot, controls, metadata);

        this.graph_data = new GraphData();

        // Scale for calculating width of covariance network link on canvas.
        this.link_scale = d3.scaleQuantize()
                .domain([0, this.max_covariance])
                .range([.5, 2, 5, 10]);

        this.C2S = require('canvas2svg');
    }

    /**
     * Create data structure with entry for each element, representing a link in the covariance graph,
     * of the covariance matrix.
     *
     * @param {[][]} m The covariance matrix data.
     */
    parse_covariance(m) {
        m.forEach((arr, idx) => {

            //Removing superflous empty value at end of each array
            arr.filter(v => v.length > 1).forEach((val, i) => {
                if (i != idx) {
                    let o = {
                        "source": String(idx),
                        "target": String(i),
                        "value": Number(val.trim())
                    }
                    this.graph_data.displayed_links.push(o);
                    this.graph_data.all_links.push(o);
                    if (Math.abs((Number(val.trim()))) > this.max_covariance) {
                        this.max_covariance = Math.abs(Number(val.trim()));
                    }
                }
            });
        });
    }

    /**
     * Parses the TreeScaper bipartition matrix producing a BP -> tree object.
     * Key: bipartition number; Value: array of trees where the bipartition is present.
     * @param {[][]} m - Bipartition Matrix generated by TreeScaper
     */
    parse_bipartition_cov(m) {
        let b = {};
        m.forEach(r => {
            //let bp_name = String(Number(r[0].trim()) + 1);
            let bp_name = String(Number(r[0].trim()));
            if (!(bp_name in b)) {
                b[bp_name] = [];
            }
            b[bp_name].push(r[1]);
        });

        Object.keys(b).forEach(k => {
            let o = {
                "id": k,
                "num_trees": b[k].length
            };
            this.graph_data.nodes.push(o);
            if (b[k].length > this.num_trees) {
                this.num_trees = b[k].length;
            }
        });

         this.node_radius_scale = d3.scaleLinear()
        .domain(d3.extent(this.graph_data.nodes, d => d.num_trees))
        .range([CovariancePlot.cov_node_r / 1.8, CovariancePlot.cov_node_r]);
    }

    /**
     * Parses taxa into array
     * @param {Object} d - Raw file data
     */
    parse_taxa_array(d) {
        let arr = d.split('\n')
        arr.pop();
        arr.shift();
        arr.forEach(e => {
            this.taxa_array.push(e.split(',')[1].trim());
        });
    }

    /**
     * Parse the bipartion count file
     *
     *  0, 000000000000000010011000000, 11
        1, 001111111111000000000100000, 10
        2, 001100001111111111111011110, 1
        3, 000011111111111100000011110, 1
     *
     * @param {*} m - bipartition count file. An array of strings
     */
    parse_taxa_partitions(m) {
        let part_taxa = {};
        m.forEach(line => {
            let arr = line[0].split(' ');
            let bp = Number(arr[0]) + 1;
            part_taxa[bp] = [];
            arr[1].trim().split("").forEach((e, idx) => {
                if (e === "1") {
                    part_taxa[bp].push(this.taxa_array[idx]);
                }
            });
        });
        return part_taxa;
    }

    build_controls() {
        let pcc = document.getElementById(this.controls);

        let field_div = document.createElement('div');
        field_div.setAttribute('class', 'field has-addons');

        let label = document.createElement('label');
        label.setAttribute('for', 'link-strength');
        label.textContent = 'Remove links below X% of maximum: ';

        let control_div = document.createElement('div');
        control_div.setAttribute('class', 'control');

        let link_strength_input = document.createElement('input');
        link_strength_input.setAttribute('type', 'number');
        link_strength_input.setAttribute('id', 'link-strength');
        link_strength_input.setAttribute('min', 1);
        link_strength_input.setAttribute('max', 100);
        link_strength_input.setAttribute('value', 50);
        link_strength_input.setAttribute('size', 4);

        // Create slider for selecting tree to display.
        let slider_input = document.createElement('input');
        slider_input.setAttribute('type', 'range');
        slider_input.setAttribute('id', 'link-strength-slider');
        slider_input.setAttribute('min', 1);
        slider_input.setAttribute('max', 100);
        slider_input.setAttribute('value', 50);
        slider_input.setAttribute('size', 4);
        slider_input.setAttribute('step', 1);
        slider_input.setAttribute('name', 'link-strength');

        let space_buffer = document.createTextNode('\u00A0\u00A0');

        control_div.append(link_strength_input, space_buffer, slider_input);

        field_div.append(label, control_div)

        pcc.append(field_div);

        link_strength_input.addEventListener("input", event => {
            let thresh = Number(document.getElementById("link-strength").value);
            document.getElementById("link-strength-slider").value = thresh;

            this.update_links(thresh);
            this.update();
        });

        slider_input.addEventListener("input", event => {
            let thresh = Number(document.getElementById("link-strength-slider").value);
            document.getElementById("link-strength").value = thresh;

            this.update_links(thresh);
            this.update();
        });

        this.canvas.addEventListener('wheel', event => {

            // DEV Only if focused
            event.preventDefault();

            let new_scale = this.scale + event.deltaY * .001;
            if (new_scale < .2) {
                this.scale = .2;
            } else if (new_scale > 5) {
                this.scale = 5;
            } else {
                this.scale = new_scale;
            }

            this.simulation.force('collision', d3.forceCollide(CovariancePlot.cov_node_r*this.scale));
            this.simulation.force("link", d3.forceLink()
                .id(function (d) { return d.id; }).distance(this.scale*this.canvas_width / 2).strength(d => d.value < -1*this.max_covariance*.01 ? this.scale*weight_scale(d.value) : 0));
        });

        this.update();
    }

    /**
     * Creates HTML displaying information on selected node.
     *
     * @param {Object} p Profiled node data
     */
    build_metadata(p) {
        const elm = document.getElementById(this.metadata);
        //elm.classList.add("box");
        let e_string = `
        <h4>Partition ${p.id}</h4>
        <table class="table"><thead><tr>
        <th>Tree Count</th><th># Pos. Cova</th><th>Mean Pos. Cova</th><th>Max Pos. Cova</th>
        <th># Neg. Cova</th><th>Mean Neg. Cova</th><th>Max Neg. Cova</th></tr></thead>
        <tbody>
        <td>${p.num_trees}</td><td>${p.num_pos_cova}</td><td>${p.mean_pos_cova.toPrecision(4)}</td><td>${p.max_pos_cova.toPrecision(4)}</td>
        <td>${p.num_neg_cova}</td><td>${p.mean_neg_cova.toPrecision(4)}</td><td>${p.max_neg_cova.toPrecision(4)}</td>
        </tbody>
        </table>
        `
        elm.innerHTML = e_string;
    }

    is_highlighted_bipartition = function(b) {
        return (b == this.current_bipartition || this.selected_bipartitions.includes(b));
    }

    /**
     * Draw a single node in covariance network.
     *
     * @param {Object} d Node object.
     */
    drawNode(d, ctx) {
        ctx.beginPath();
        //ctx.moveTo(d.x, d.y);
        let default_r = this.scale*this.node_radius_scale(d.num_trees);
        let r = this.is_highlighted_bipartition(d.id) ? default_r * 1.2 : default_r;
        ctx.arc(d.x, d.y, r, 0, Math.PI * 2);
        ctx.globalAlpha = this.set_node_alpha(d);
        ctx.fillStyle = this.set_fillstyle(d);
        ctx.strokeStyle = 'black';
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.lineWidth = 1;
        ctx.stroke();
    }


    /**
     * Sets alpha for covariance network link in proportion to its relation to the maximum magnitude for all links.
     *
     * @param {Object} l Link
     */
    set_link_alpha(l) {
        let alpha = 1 - ((this.max_covariance - Math.abs(l.value)) / this.max_covariance);
        return alpha;
    }

    /**
     * Sets alpha for covariance network node in proportion to the frequency of its occurence in the corresponding tree set.
     *
     * @param {Object} d Node
     */
    set_node_alpha(d) {
        if (this.is_highlighted_bipartition(d.id)) {
            return 1.0;
        }
        let alpha_pct = .25 + .5*(d.num_trees / this.num_trees);
        if (alpha_pct < 0.1) { alpha_pct = 0.1 };
        if (this.cd_groups) {
            return 1.0;
        } else {
            return alpha_pct;
        }
    }

    /**
     * Sets color for covariance network node.
     *
     * @param {Object} d Node object
     */
    set_fillstyle(d) {

        // Neon green if highlighted.
        if (this.is_highlighted_bipartition(d.id)) {
            return "rgba(57, 255, 20, 1)";
        }

        // If we have corresponding CD data, use those colors.
        if (this.cd_groups) {
            try {
                let x = this.cd_groups[Number(d.id)].color;
                return x;
            } catch (error) {
                return "white";
            }
        } else {
            return "black";
        }
    }

    /**
     * Draw a single link in covariance network.
     *
     * @param {Object} l Link object.
     */
    drawLink(l, ctx) {
        if (l.value < 0) {
            ctx.strokeStyle = "red";
        } else if (l.value > 0) {
            ctx.strokeStyle = "blue";
        } else {
            ctx.strokeStyle = "lime";
            ctx.lineDashOffset = 1;
        }
        ctx.beginPath();
        ctx.globalAlpha = this.set_link_alpha(l);
        ctx.lineWidth = this.link_scale(Math.abs(l.value)) / 5;
        ctx.moveTo(l.source.x, l.source.y);
        ctx.lineTo(l.target.x, l.target.y);
        ctx.stroke();
    }

    /**
     * Redraws covariance network on existing covariance-canvas element.
     *
     * DEV renamed from redraw_full_cov_graph
     */
    update() {
            let ctx = this.canvas.getContext('2d');
            ctx.beginPath();
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            set_background(ctx, this.canvas.width, this.canvas.height);
            ctx.globalAlpha = 1.0;


            // Create brand new dummy_ctx
            this.dummy_ctx = C2S(this.canvas.width, this.canvas.height);
            this.dummy_ctx.beginPath();
            this.dummy_ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            set_background(this.dummy_ctx, this.canvas.width, this.canvas.height);
            this.dummy_ctx.globalAlpha = 1.0;

            for (const l of this.graph_data.displayed_links) {
                this.drawLink(l, ctx);
                this.drawLink(l, this.dummy_ctx);
            }
            for (const l of this.graph_data.nodes) {
                this.drawNode(l, ctx);
                this.drawNode(l, this.dummy_ctx);
            }
    }

    /**
     * Create an adjacency list from the covariance matrix.
     */
    build_matrix() {
        this.filtered_adjacency_list = {}; //Matrix as adjacency list
        this.graph_data.nodes.forEach(n => {
            this.filtered_adjacency_list[n.id] = [];
        });
        this.graph_data.displayed_links.forEach(l => {
            this.filtered_adjacency_list[l.source.id].push({ id: l.target.id, covariance: l.value });
        });
    }


    /*
     * Populates graph_data.displayed_links by selecting only links above a certain threshold.
     * These are the links that are actually drawn on the visualization. The user may adjust this threshold
     * in the interface, and the links are redrawn.
     *
     * This function also rebuilds the filtered_adjacency_list
     *
     * @param {number} link_threshold The threshold in percentage of maximum covariance
     */
    update_links(link_threshold) {
        let link_strength_thresh = link_threshold / 100.0;
        let edited_links = [];
        this.graph_data.all_links.forEach(obj => {
            if (Math.abs(obj.value) >= (link_strength_thresh * this.max_covariance)) {
                edited_links.push(obj);
            }
        });
        this.graph_data.displayed_links = edited_links;
        this.build_matrix();
    }

    draw() {
        // Remove child-nodes of cov-plot and recreate canvas as child
        removeChildNodes(this.plot);

        let doc_width = document.getElementById(this.plot).clientWidth;
        //let width = Math.floor((doc_width - (.02 * doc_width)) / 100) * 100;
        let width = doc_width;
        let height = width;

        // Create new canvas
        this.canvas = document.createElement('canvas');

        // Set canvas attributes
        this.canvas.setAttribute('id', CovariancePlot.canvas_plot_element_id)
        this.canvas.setAttribute("width", width);
        this.canvas.setAttribute("height", height);

        // Add canvas to document
        document.getElementById(this.plot).append(this.canvas);

        // Create dummy canvas context
        let C2S = require('canvas2svg');
        this.dummy_ctx = C2S(width, height);

        let ctx = this.canvas.getContext('2d');

        let plot_object = this;
        // Tick function that redraws the graph and tooltip
        let tick = function () {
            // Create bounds
            for (const d of plot_object.graph_data.nodes) {
                let radius = plot_object.scale * CovariancePlot.cov_node_r;
                d.x = Math.max(radius, Math.min(width - radius, d.x));
                d.y = Math.max(radius, Math.min(height- radius, d.y));
            }
            plot_object.update();
        };

         let weight_scale = d3.scaleLinear()
        .domain(d3.extent(this.graph_data.all_links, d => d.value))
        .range([1.5, 0]);

        // d3 library that simulates forces acting between and on the graph nodes
        this.simulation = d3.forceSimulation(this.graph_data.nodes)
            .force('center', d3.forceCenter(width / 2, height / 2).strength(1))
            .force('collision', d3.forceCollide(CovariancePlot.cov_node_r))
            .force("gravity", d3.forceManyBody().strength(2))
            .force("link", d3.forceLink()
                .id(function (d) { return d.id; }).distance(width / 2).strength(d => d.value < -1*this.max_covariance*.01 ? weight_scale(d.value) : 0));

        // Assign our function to the simulation tick
        this.simulation.on("tick", () => {
            tick();
        });

        // Add links to simulation
        this.simulation.force("link")
            .links(this.graph_data.all_links);

        let subject = undefined;

        let dragstarted = function () {
            if (!d3.getEvent().active) this.simulation.alphaTarget(0.3).restart();
            subject = this.simulation.find(d3.getEvent().offsetX, d3.getEvent().offsetY);
            subject.fx = subject.x;
            subject.fy = subject.y;
        }.bind(this);

        let dragged = function () {
            //subject = simulation.find(d3.getEvent().offsetX, d3.getEvent().offsetY);
            subject.fx = d3.getEvent().offsetX;
            subject.fy = d3.getEvent().offsetY;
        }.bind(this);

        let dragended = async function () {
            // DEV Why is setting the subject initially not working?
            subject = this.simulation.find(d3.getEvent().offsetX, d3.getEvent().offsetY);
            if (!d3.getEvent().active) this.simulation.alphaTarget(0);
            subject.fx = null;
            subject.fy = null;
            //simulation.stop();
            //await new Promise(r => setTimeout(r, 1000));
            //simulation.restart();
        }.bind(this);

        // DEV Figure out drag
        d3.select(this.canvas)
            .call(d3.drag()
                .container(this.canvas)
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        // This populates the displayed_links field with only links above a certain threshold.
        this.update_links(50);

        plot_object.update();
    }
}

export { CovariancePlot }
