import { scaleQuantize } from "d3-scale";
import { forceSimulation, forceCollide, forceManyBody, forceLink, forceX, forceY, forceCenter } from "d3-force";
import { create, select } from "d3-selection";
import { drag } from "d3-drag";
import { mean, max, ascending } from "d3-array";
import { hierarchy, cluster, tree } from "d3-hierarchy";
import { scaleLinear, eas } from "d3-scale";

import { roundedRect } from "../utilities/support_funcs";
import { removeChildNodes, cleanExistingPlot, htmlToElement } from "../utilities/html_templates";
import { css_colors } from "../utilities/colors";
import { build_event, set_background } from "../utilities/support_funcs";
import { CloudForestPlot } from "./cloudforest_plot.js";

const getEvent = () => event; // This is necessary when using webpack >> https://github.com/d3/d3-zoom/issues/32
const d3 = Object.assign(
    {
        mean,
        max,
        select,
        event,
        getEvent,
        drag,
        hierarchy,
        ascending,
        scaleLinear,
        create,
        scaleQuantize,
        forceSimulation,
        forceCollide,
        forceManyBody,
        forceLink,
        forceX,
        forceY,
        forceCenter
    }
);


class GraphData {
    "nodes" = [];
    // Only links that are displayed. Links with a covariance below a certain threshold
    // will not be in this list.
    "displayed_links" = [];
    "all_links" = [];
}

class CovariancePlot extends CloudForestPlot {

    static canvas_plot_element_id = 'covariance-canvas';

    // Radius for covariance plot nodes
    static cov_node_r = 5;
    static highlight_cov_node_r = 7;

    max_covariance = 0;
    taxa_array = [];
    canvas = undefined;
    link_scale = undefined;
    cd_groups = undefined;

    // Representation of covariance network
    filtered_adjacency_list = undefined;

    // Number of trees for phylogram
    num_trees = 0;

    constructor(plot, controls, metadata) {
        super(plot, controls, metadata);
        this.graph_data = new GraphData();

        // Scale for calculating width of covariance network link on canvas.
        this.link_scale = d3.scaleQuantize()
                .domain([0, this.max_covariance])
                .range([.5, 2, 5, 10]);
    }

    /**
     * Create data structure with entry for each element, representing a link in the covariance graph,
     * of the covariance matrix.
     *
     * @param {[][]} m The covariance matrix data.
     */
    parse_covariance(m) {
        m.forEach((arr, idx) => {
    
            //Removing superflous empty value at end of each array
            arr.filter(v => v.length > 1).forEach((val, i) => {
                if (i != idx) {
                    let o = {
                        "source": String(idx),
                        "target": String(i),
                        "value": Number(val.trim())
                    }
                    this.graph_data.displayed_links.push(o);
                    this.graph_data.all_links.push(o);
                    if (Math.abs((Number(val.trim()))) > this.max_covariance) {
                        this.max_covariance = Math.abs(Number(val.trim()));
                    }
                }
            });
        });
    }

    /**
     * Parses the TreeScaper bipartition matrix producing a BP -> tree object.
     * Key: bipartition number; Value: array of trees where the bipartition is present.
     * @param {[][]} m - Bipartition Matrix generated by TreeScaper
     */
    parse_bipartition_cov(m) {
        let b = {};
        m.forEach(r => {
            //let bp_name = String(Number(r[0].trim()) + 1);
            let bp_name = String(Number(r[0].trim()));
            if (!(bp_name in b)) {
                b[bp_name] = [];
            }
            b[bp_name].push(r[1]);
        });
    
        Object.keys(b).forEach(k => {
            let o = {
                "id": k,
                "num_trees": b[k].length
            };
            this.graph_data.nodes.push(o);
            if (b[k].length > this.num_trees) {
                this.num_trees = b[k].length;
            }
        });
    }

    /**
     * Parses taxa into array
     * @param {Object} d - Raw file data
     */
    parse_taxa_array(d) {
        let arr = d.split('\n')
        arr.pop();
        arr.shift();
        arr.forEach(e => {
            this.taxa_array.push(e.split(',')[1].trim());
        });
    }

    /**
     * Parse the bipartion count file
     *
     *  0, 000000000000000010011000000, 11
        1, 001111111111000000000100000, 10
        2, 001100001111111111111011110, 1
        3, 000011111111111100000011110, 1
     *
     * @param {*} m - bipartition count file. An array of strings
     */
    parse_taxa_partitions(m) {
        let part_taxa = {};
        m.forEach(line => {
            let arr = line[0].split(' ');
            let bp = Number(arr[0]) + 1;
            part_taxa[bp] = [];
            arr[1].trim().split("").forEach((e, idx) => {
                if (e === "1") {
                    part_taxa[bp].push(this.taxa_array[idx]);
                }
            });
        });
        return part_taxa;
    }

    build_controls() {
        let pcc = document.getElementById(this.controls);
        pcc.append(htmlToElement(`<div class="field has-addons">
            <h4>Remove Links Below&nbsp;</h4>
            <div class="control">
                <input type="number" id="link-strength" min="1" max="100" value="50" size="4"></input>
            </div >
            <h4>% of Maximum Magnitude</h4>
            </div > `));
        document.getElementById("link-strength").addEventListener("input", event => {
            let thresh = Number(document.getElementById("link-strength").value);
            this.update_links(thresh);
            this.draw_covariance();
        });
    }

    /**
     * Creates HTML displaying information on selected node.
     *
     * @param {Object} p Profiled node data
     */
    build_metadata(p) {
        const elm = document.getElementById(this.metadata);
        //elm.classList.add("box");
        let e_string = `
        <h4>Partition ${p.id}</h4>
        <table class="table"><thead><tr>
        <th>Tree Count</th><th># Pos. Cova</th><th>Mean Pos. Cova</th><th>Max Pos. Cova</th>
        <th># Neg. Cova</th><th>Mean Neg. Cova</th><th>Max Neg. Cova</th></tr></thead>
        <tbody>
        <td>${p.num_trees}</td><td>${p.num_pos_cova}</td><td>${p.mean_pos_cova.toPrecision(4)}</td><td>${p.max_pos_cova.toPrecision(4)}</td>
        <td>${p.num_neg_cova}</td><td>${p.mean_neg_cova.toPrecision(4)}</td><td>${p.max_neg_cova.toPrecision(4)}</td>
        </tbody>
        </table>
        `
        elm.innerHTML = e_string;
    }

    // DEV
    is_highlighted_bipartition(id) {
        return false;
    }

    /**
     * Draw a single node in covariance network.
     *
     * @param {Object} d Node object.
     */
    drawNode(d, ctx) {
        ctx.beginPath();
        ctx.moveTo(d.x, d.y);
        let r = this.is_highlighted_bipartition(d.id) ? CovariancePlot.highlight_cov_node_r : CovariancePlot.cov_node_r;
        ctx.arc(d.x, d.y, r, 0, Math.PI * 2);
        ctx.globalAlpha = this.set_node_alpha(d);
        ctx.fillStyle = this.set_fillstyle(d);
        ctx.fill();
    }
    
    
    /**
     * Sets alpha for covariance network link in proportion to its relation to the maximum magnitude for all links.
     *
     * @param {Object} l Link
     */
    set_link_alpha(l) {
        let alpha = 1 - ((this.max_covariance - Math.abs(l.value)) / this.max_covariance);
        return alpha;
    }
    
    /**
     * Sets alpha for covariance network node in proportion to the frequency of its occurence in the corresponding tree set.
     *
     * @param {Object} d Node
     */
    set_node_alpha(d) {
        if (this.is_highlighted_bipartition(d.id)) {
            return 1.0;
        }
        let alpha_pct = (d.num_trees / this.num_trees);
        if (alpha_pct < 0.1) { alpha_pct = 0.1 };
        if (this.cd_groups) {
            return 1.0;
        } else {
            return alpha_pct;
        }
    }
    
    /**
     * Sets color for covariance network node.
     *
     * @param {Object} d Node object
     */
    set_fillstyle(d) {
    
        // Neon green if highlighted.
        // DEV
        //if (is_highlighted_bipartition(d.id)) {
        //    return "rgba(57, 255, 20, 1)";
        //}
    
        // If we have corresponding CD data, use those colors.
        if (this.cd_groups) {
            try {
                let x = this.cd_groups[Number(d.id)].color;
                return x;
            } catch (error) {
                return "white";
            }
        } else {
            return "black";
        }
    }

    /**
     * Draw a single link in covariance network.
     *
     * @param {Object} l Link object.
     */
    drawLink(l, ctx) {
        if (l.value < 0) {
            ctx.strokeStyle = "red";
        } else if (l.value > 0) {
            ctx.strokeStyle = "blue";
        } else {
            ctx.strokeStyle = "lime";
            ctx.lineDashOffset = 1;
        }
        ctx.beginPath();
        ctx.globalAlpha = this.set_link_alpha(l);
        ctx.lineWidth = this.link_scale(Math.abs(l.value)) / 5;
        ctx.moveTo(l.source.x, l.source.y);
        ctx.lineTo(l.target.x, l.target.y);
        ctx.stroke();
    }

    /**
     * Redraws covariance network on existing covariance-canvas element.
     *
     * DEV renamed from redraw_full_cov_graph
     */
    draw_covariance() {
            let ctx = this.canvas.getContext('2d');
            ctx.beginPath();
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            set_background('covariance-canvas');
            ctx.globalAlpha = 1.0;
            for (const l of this.graph_data.displayed_links) {
                this.drawLink(l, ctx);
            }
            for (const l of this.graph_data.nodes) {
                this.drawNode(l, ctx);
            }
    }

    /**
     * Create an adjacency list from the covariance matrix.
     */
    build_matrix() {
        this.filtered_adjacency_list = {}; //Matrix as adjacency list
        this.graph_data.nodes.forEach(n => {
            this.filtered_adjacency_list[n.id] = [];
        });
        this.graph_data.displayed_links.forEach(l => {
            this.filtered_adjacency_list[l.source.id].push({ id: l.target.id, covariance: l.value });
        });
    }
    
    
    /*
     * Populates graph_data.displayed_links by selecting only links above a certain threshold.
     * These are the links that are actually drawn on the visualization. The user may adjust this threshold
     * in the interface, and the links are redrawn.
     *
     * This function also rebuilds the filtered_adjacency_list
     *
     * @param {number} link_threshold The threshold in percentage of maximum covariance
     */
    update_links(link_threshold) {
        let link_strength_thresh = link_threshold / 100.0;
        let edited_links = [];
        this.graph_data.all_links.forEach(obj => {
            if (Math.abs(obj.value) >= (link_strength_thresh * this.max_covariance)) {
                edited_links.push(obj);
            }
        });
        this.graph_data.displayed_links = edited_links;
        this.build_matrix();
    }

    draw() {
        // Remove child-nodes of cov-plot and recreate canvas as child
        removeChildNodes(this.plot);

        let doc_width = document.getElementById(this.plot).clientWidth;
        let width = Math.floor((doc_width - (.15 * doc_width)) / 100) * 100;
        let height = width;

        // Create new canvas
        this.canvas = document.createElement('canvas');

        // Set canvas attributes
        this.canvas.setAttribute('id', this.canvas_plot_element_id)
        this.canvas.setAttribute("width", width);
        this.canvas.setAttribute("height", height);

        // Add canvas to document
        document.getElementById(this.plot).append(this.canvas);

        let ctx = this.canvas.getContext('2d');

        let plot_object = this;
        // Tick function that redraws the graph and tooltip
        let tick = function () {
            plot_object.draw_covariance();
            // DEV
            //if (tooltip !== null) {
            //    this.draw_tooltip();
            //}
        };

        // d3 library that simulates forces acting between and on the graph nodes
        let simulation = d3.forceSimulation(this.graph_data.nodes)
            .force('center', d3.forceCenter(width / 2, height / 2))
            .force("x", d3.forceX(width / 2))
            .force("y", d3.forceY(height / 2))
            .force("charge", d3.forceManyBody().strength(-20))
            .force("link", d3.forceLink()
                .id(function (d) { return d.id; }).distance(width / 3));

        // Assign our function to the simulation tick
        simulation.on("tick", () => {
            tick();
        });

        // Add links to simulation
        simulation.force("link")
            .links(this.graph_data.all_links);

        // This populates the displayed_links field with only links above a certain threshold.
        this.update_links(50);

    }
}

export { CovariancePlot }
