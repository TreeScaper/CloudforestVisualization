import { scaleQuantize } from "d3-scale";
import { forceSimulation, forceCollide, forceManyBody, forceLink, forceX, forceY, forceCenter } from "d3-force";
import { create, select } from "d3-selection";
import { drag } from "d3-drag";
import { mean, max, ascending } from "d3-array";
import { hierarchy, cluster, tree } from "d3-hierarchy";
import { scaleLinear, eas } from "d3-scale";

import { roundedRect } from "./support_funcs";
import { removeChildNodes, cleanExistingPlot, htmlToElement } from "./html_templates";
import { css_colors } from "./colors";
import { build_event } from "./support_funcs";
import { parse_taxa_partitions } from "./bipartition_data.js";
import { get_root } from "./phylogram.js";
import { newick_parse } from "./tree_data_parsing"

const getEvent = () => event; // This is necessary when using webpack >> https://github.com/d3/d3-zoom/issues/32
const d3 = Object.assign(
    {
        mean,
        max,
        select,
        event,
        getEvent,
        scaleQuantize,
        forceSimulation, forceCollide, forceManyBody, forceLink, forceX, forceY, forceCenter,
        drag,
        hierarchy,
        ascending,
        scaleLinear,
        create
    }
);


let graph_data = undefined;
let tooltip = null;
let filtered_adjacency_list = undefined;
let bipartition_files = undefined;
let cd_groups = undefined;
let max_covariance = 0;
let num_trees = 0;
let taxa_array = [];
let tree_links = [];
let tree_root = undefined;
let scale_x = undefined;
let scale_y = undefined;
let current_link = null;
let selected_links = [];
let current_bipartition = null;
let selected_bipartitions = [];
let parsed_bipartition_taxa = undefined;
let boottree_data = undefined;
const node_radius = 5;
const cov_node_r = 5;
const highlight_cov_node_r = 7;

const FILE_NAME_REGEX = /^Covariance Matrix/;

const parse_cd = function (groups) {
    let d = {};
    let hsl_colors = Object.keys(groups).map((v, i) => {
        return css_colors[i];
    });

    Object.keys(groups).forEach((k, idx) => {
        groups[k].forEach(bp => {
            d[bp] = { group: k, color: hsl_colors[idx] };
        });
    });
    cd_groups = d;
}

const parse_covariance = function (m) {
    m.forEach((arr, idx) => {
        //Removing superflous empty value at end of each array
        arr.filter(v => v.length > 1).forEach((val, i) => {
            if (i != idx) {
                let o = {
                    "source": String(idx),
                    "target": String(i),
                    "value": Number(val.trim())
                }
                graph_data.displayed_links.push(o);
                graph_data.all_links.push(o);
                if (Math.abs((Number(val.trim()))) > max_covariance) {
                    max_covariance = Math.abs(Number(val.trim()));
                }
            }
        });
    });
}

/**
 * Parses the TreeScaper bipartition matrix producing a BP -> tree object.
 * Key: bipartition number; Value: array of trees where the bipartition is present.
 * @param {[]} m - Bipartition Matrix generated by TreeScaper
 */
const parse_bipartition_cov = function (m) {
    let b = {};
    m.forEach(r => {
        //let bp_name = String(Number(r[0].trim()) + 1);
        let bp_name = String(Number(r[0].trim()));
        if (!(bp_name in b)) {
            b[bp_name] = [];
        }
        b[bp_name].push(r[1]);
    });

    Object.keys(b).forEach(k => {
        let o = {
            "id": k,
            "num_trees": b[k].length
        };
        graph_data.nodes.push(o);
        if (b[k].length > num_trees) {
            num_trees = b[k].length;
        }
    });
}

/**
     * Return a profile for the requested node, including
     * link information
     * @param {*} node
     */
const profile_node = function (node) {
    let r_val = {
        "id": node.id,
        "num_trees": node.num_trees
    };
    let pos_values = [];
    let neg_values = [];
    graph_data.all_links.forEach(l => {
        if (l.source === node.id || l.target === node.id) {
            if (l.value < 0) {
                neg_values.push(l.value);
            }
            if (l.value >= 0) {
                pos_values.push(l.value);
            }
        }
    });
    r_val["num_pos_cova"] = pos_values.length;// || NaN;
    r_val["num_neg_cova"] = neg_values.length;// || NaN;
    r_val["mean_pos_cova"] = d3.mean(pos_values);// || NaN;
    r_val["mean_neg_cova"] = d3.mean(neg_values) || NaN;
    r_val["max_neg_cova"] = -1 * d3.max(neg_values.map(v => Math.abs(v))) || NaN;
    r_val["max_pos_cova"] = d3.max(pos_values);// || NaN;
    return r_val;
}

const draw_profile_legend = function (p) {
    const elm = document.getElementById("plot-metadata");
    //elm.classList.add("box");
    let e_string = `
    <h4>Partition ${p.id}</h4>
    <table class="table"><thead><tr>
    <th>Tree Count</th><th># Pos. Cova</th><th>Mean Pos. Cova</th><th>Max Pos. Cova</th>
    <th># Neg. Cova</th><th>Mean Neg. Cova</th><th>Max Neg. Cova</th></tr></thead>
    <tbody>
    <td>${p.num_trees}</td><td>${p.num_pos_cova}</td><td>${p.mean_pos_cova.toPrecision(4)}</td><td>${p.max_pos_cova.toPrecision(4)}</td>
    <td>${p.num_neg_cova}</td><td>${p.mean_neg_cova.toPrecision(4)}</td><td>${p.max_neg_cova.toPrecision(4)}</td>
    </tbody>
    </table>
    `
    elm.innerHTML = e_string;
}

//Set background so saved PNG has a background color.
const set_background = function(canvas_id) {
    let canvas = document.getElementById(canvas_id);
    let ctx = undefined;
    if (canvas != null) {
        ctx = canvas.getContext('2d');
        //ctx.globalCompositeOperation = 'destination-over'
        ctx.fillStyle = "white";
        ctx.globalAlpha = 1.0;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
}

const link_scale = d3.scaleQuantize()
        .domain([0, max_covariance])
        .range([.5, 2, 5, 10]);

const is_highlighted_bipartition = function(b) {
    return (b == current_bipartition || selected_bipartitions.includes(b));
}

const drawNode = function (d) {
    let canvas = document.getElementById("topo-network");
    let ctx = canvas.getContext('2d');
    ctx.beginPath();
    ctx.moveTo(d.x, d.y);
    let r = is_highlighted_bipartition(d.id) ? highlight_cov_node_r : cov_node_r;
    ctx.arc(d.x, d.y, r, 0, Math.PI * 2);
    ctx.globalAlpha = set_node_alpha(d);
    ctx.fillStyle = set_fillstyle(d);
    ctx.fill();
}


const drawLink = function (l) {
    let canvas = document.getElementById("topo-network");
    let ctx = canvas.getContext('2d');
    if (l.value < 0) {
        ctx.strokeStyle = "red";
    } else if (l.value > 0) {
        ctx.strokeStyle = "blue";
    } else {
        ctx.strokeStyle = "lime";
        ctx.lineDashOffset = 1;
    }
    ctx.beginPath();
    ctx.globalAlpha = set_link_alpha(l);
    ctx.lineWidth = link_scale(Math.abs(l.value)) / 5;
    ctx.moveTo(l.source.x, l.source.y);
    ctx.lineTo(l.target.x, l.target.y);
    ctx.stroke();
}

const redraw_full_cov_graph = function () {
        let canvas = document.getElementById("topo-network");
        let cov_ctx = canvas.getContext('2d');
        cov_ctx.beginPath();
        cov_ctx.clearRect(0, 0, canvas.width, canvas.height);
        set_background('topo-network');
        cov_ctx.globalAlpha = 1.0;
        graph_data.displayed_links.forEach(drawLink);
        graph_data.nodes.forEach(drawNode);
}

const set_link_alpha = function (l) {
    let alpha = 1 - ((max_covariance - Math.abs(l.value)) / max_covariance);
    return alpha;
}

const set_node_alpha = function (d) {
    if (is_highlighted_bipartition(d.id)) {
        return 1.0;
    }
    let alpha_pct = (d.num_trees / num_trees);
    if (alpha_pct < 0.1) { alpha_pct = 0.1 };
    if (cd_groups) {
        return 1.0;
    } else {
        return alpha_pct;
    }
}

const set_fillstyle = function (d) {
    if (is_highlighted_bipartition(d.id)) {
        return "rgba(57, 255, 20, 1)";
    }
    if (cd_groups) {
        try {
            let x = cd_groups[Number(d.id)].color;
            return x;
        } catch (error) {
            return "white";
        }
    } else {
        return "black";
    }
}

const draw_tooltip = function () {
    let x_tooltip_width_abs = 100;
    let y_tooltip_width_abs = 18;

    let x_tooltip_mag = (tooltip.x < x_tooltip_width_abs) ? -1 : 1;
    let y_tooltip_mag = (tooltip.y < y_tooltip_width_abs) ? -1 : 1;

    let x_tooltip_width = x_tooltip_mag * x_tooltip_width_abs;
    let y_tooltip_width = y_tooltip_mag * y_tooltip_width_abs;

    // ctx.beginPath();
    // ctx.fillStyle = "lime";
    // ctx.globalAlpha = 1.0;
    // ctx.fillRect(x - x_tooltip_width, y - y_tooltip_width, x_tooltip_width, y_tooltip_width);
    tooltip.ctx.beginPath();
    tooltip.ctx.globalAlpha = 1.0;
    tooltip.ctx.fillStyle = "black";
    tooltip.ctx.font = '18px serif';
    let x_text_loc = (x_tooltip_mag == 1) ? tooltip.x - x_tooltip_width + 5 : tooltip.x + 5;
    let y_text_loc = (y_tooltip_mag == 1) ? tooltip.y - 5 : tooltip.y  - y_tooltip_width + 5;
    tooltip.ctx.fillText(tooltip.text, x_text_loc, y_text_loc);
}

const draw_graph = function () {

    let canvas = document.getElementById("topo-network"),
        ctx = canvas.getContext('2d'),
        width = canvas.getAttribute("width"),
        height = canvas.getAttribute("height");

    selected_bipartitions = [];

    let tick = function () {
        redraw_full_cov_graph();
        if (tooltip !== null) {
            draw_tooltip();
        }
    }
    let simulation = d3.forceSimulation(graph_data.nodes)
        .force('center', d3.forceCenter(width / 2, height / 2))
        .force("x", d3.forceX(width / 2))
        .force("y", d3.forceY(height / 2))
        .force("charge", d3.forceManyBody().strength(-20))
        .force("link", d3.forceLink()
            .id(function (d) { return d.id; }).distance(width / 3));

    simulation.on("tick", () => {
        tick();
    });
    simulation.force("link")
        .links(graph_data.all_links);

    let dragstarted = function () {
        if (!d3.getEvent().active) simulation.alphaTarget(0.3).restart();
        d3.getEvent().subject.fx = d3.getEvent().subject.x;
        d3.getEvent().subject.fy = d3.getEvent().subject.y;
    }

    let dragged = function () {
        d3.getEvent().subject.fx = d3.getEvent().x;
        d3.getEvent().subject.fy = d3.getEvent().y;
    }

    let dragended = async function () {
        if (!d3.getEvent().active) simulation.alphaTarget(0);
        d3.getEvent().subject.fx = null;
        d3.getEvent().subject.fy = null;
        let p = profile_node(d3.getEvent().subject);
        draw_profile_legend(p);
        ctx.beginPath();
        ctx.fillStyle = "black";
        ctx.globalAlpha = 0.5;
        roundedRect(ctx, d3.getEvent().subject.x - 10, d3.getEvent().subject.y - 30, 250, 50, 5);
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = "white";
        ctx.font = "bold 15px Arial";
        ctx.fillText(`Partition ${p.id} - Trees: ${p.num_trees} `, d3.getEvent().subject.x, d3.getEvent().subject.y, 200);
        simulation.stop();
        await new Promise(r => setTimeout(r, 1000));
        simulation.restart();
    }

    let dragsubject = function () {
        return simulation.find(d3.getEvent().x, d3.getEvent().y);
    }

    // d3.select(canvas)
    //     .call(d3.drag()
    //         .container(canvas)
    //         .subject(dragsubject)
    //         .on("start", dragstarted)
    //         .on("drag", dragged)
    //         .on("end", dragended));

    canvas.addEventListener("mousemove", function(e) {

        let canvas_rect = canvas.getBoundingClientRect();
        let x = e.clientX - canvas_rect.left, y = e.clientY - canvas_rect.top;

        let found_bipartition = null;
        for (const d of graph_data.nodes) {

            let dist = Math.sqrt(Math.pow(x - d.x, 2) + Math.pow(y - d.y, 2));
            if (dist < cov_node_r) {
                let tree_canvas = document.getElementById('tree-canvas');
                let tree_ctx = tree_canvas.getContext('2d');
                let bipartition_set = new Set(parsed_bipartition_taxa[d.id]);
                for (const t of tree_links) {
                    let leaf_names = [];
                    for (const leaf of t.link.target.leaves()) {
                        leaf_names.push(leaf.data.name);
                    }
                    let leaves_set = new Set(leaf_names);
                    if (set_equality(leaves_set, bipartition_set)) {
                        current_link = t;
                    }
                }
                found_bipartition = d.id;
                break;
            }
        }
        if (found_bipartition !== null) {
            if (current_bipartition !== found_bipartition) {
                current_bipartition = found_bipartition;
            }
            redraw_full_cov_graph();
            redraw_full_tree();
            tooltip = {
                ctx: ctx,
                x: x,
                y: y,
                text: `Bipartition ${found_bipartition}`
            };
            draw_tooltip();
            //draw_tooltip(ctx, x, y, found_bipartition);
        } else {
            tooltip = null;
            if (current_bipartition !== null) {
                current_link = null;
                current_bipartition = null;
                redraw_full_cov_graph();
                redraw_full_tree();
            }
        }
    });

    canvas.addEventListener("click", function(e) {
        if (current_bipartition != null) {
            if (!selected_bipartitions.includes(current_bipartition)){
                if (e.shiftKey) {
                    selected_bipartitions.push(current_bipartition);
                    selected_links.push(current_link);
                } else {
                    selected_bipartitions = [current_bipartition];
                    selected_links = [current_link];
                }
            } else {
                selected_bipartitions = selected_bipartitions.filter(b => b != current_bipartition);
                selected_links = selected_links.filter(b => b != current_link);
            }
        }
    });
}

const build_matrix = function () {
    filtered_adjacency_list = {}; //Matrix as adjacency list
    graph_data.nodes.forEach(n => {
        filtered_adjacency_list[n.id] = [];
    });
    graph_data.displayed_links.forEach(l => {
        filtered_adjacency_list[l.source.id].push({ id: l.target.id, covariance: l.value });
    });
}

const update_links = function (conf_update) {
    let link_strength_thresh = conf_update.link_threshold / 100.0;
    //edit the links
    let edited_links = [];
    graph_data.all_links.forEach(obj => {
        if (Math.abs(obj.value) >= (link_strength_thresh * max_covariance)) {
            edited_links.push(obj);
        }
    });
    graph_data.displayed_links = edited_links;
    build_matrix();
}

const build_link_edit_ui = function () {
    let pcc = document.getElementById("plot-controls");
    //pcc.classList.add("box");
    pcc.append(htmlToElement(`<div class="field has-addons">
        <h4>Remove Links Below&nbsp;</h4>
        <div class="control">
            <input type="number" id="link-strength" min="1" max="100" value="50" size="4"></input>
        </div >
        <h4>% of Maximum Magnitude</h4>
        </div > `));

    pcc.append(htmlToElement(`<div class="field has-addons">
    <div class="control">
        <button id="publish-graph" class="button is-info">Publish Graph</button>
    </div>`));

    //document.getElementById("publish-graph").disabled = true;

    document.getElementById("link-strength").addEventListener("input", event => {
        let thresh = Number(document.getElementById("link-strength").value);
        update_links({
            link_threshold: thresh
        });
        redraw_full_cov_graph();
    });

    // document.getElementById("btn-links-reset").addEventListener("click", event => {
    //     update_links({
    //         link_threshold: 50
    //     });
    //     redraw_full_cov_graph();
    //     document.getElementById("link-strength").value = 50;
    //     document.getElementById("publish-graph").disabled = true;
    // });

    document.getElementById("publish-graph").addEventListener("click", () => {

        let combined_canvas = document.createElement('canvas');
        let covariance_canvas = document.getElementById('topo-network');
        let tree_canvas = document.getElementById('tree-canvas');

        combined_canvas.setAttribute('width', covariance_canvas.width + tree_canvas.width);
        combined_canvas.setAttribute('height', Math.max(covariance_canvas.height,tree_canvas.height));
        let combined_ctx = combined_canvas.getContext('2d');

        combined_ctx.drawImage(tree_canvas, 0, 0);
        combined_ctx.drawImage(covariance_canvas, tree_canvas.width, 0);

        let download_link = document.createElement('a')
        download_link.href = combined_canvas.toDataURL('image/png');
        download_link.download = 'covariance_plot.png';
        download_link.click();

        // dispatchEvent(build_event("PublishData", {
        //     data: filtered_adjacency_list,
        //     file_name: `Filtered Adjacency at ${document.getElementById("link-strength").value}`
        // }));
    });
}

//REFACTOR THIS TO ONE MODULE
const clean_data = function(data) {
    let t_arr = data.split('\n');
    let arr = []
    t_arr.forEach(d => {
        if (d.length > 0) {
            arr.push(d.split('\t'));
        }
    });
    return arr;
}

const create_empty_line = function(ctx, source_x, source_y, target_x, target_y) {
  ctx.beginPath();
  ctx.moveTo(source_x, source_y);
  ctx.lineTo(target_x, target_y);
  ctx.lineWidth = 20;
}

const create_empty_rect = function(ctx, source_x, source_y, target_x, target_y) {
  ctx.beginPath();
  ctx.moveTo(source_x, source_y);
  ctx.lineTo(target_x, target_y);
  ctx.lineWidth = 1;
}

const draw_single_line = function(ctx, source_x, source_y, target_x, target_y, style, width, erase_width=null) {
    // Account for node radius
    let adjusted_source_y = source_y;
    let adjusted_target_y = target_y;
    if (source_y < target_y) {
        adjusted_source_y = source_y + node_radius;
    } else if (source_y > target_y) {
        adjusted_source_y = source_y - node_radius;
    }

    let adjusted_source_x = source_x;
    let adjusted_target_x = target_x;
    if (source_x < target_x) {
        adjusted_target_x = target_x - node_radius;
    } else if (source_x > target_x) {
        adjusted_target_x = target_x + node_radius;
    }

    // Eventually create a draw queue. For now we just erase old lines.
    if (erase_width !== null) {
        draw_single_line(ctx, source_x, source_y, target_x, target_y, 'white', erase_width);
    }

    ctx.beginPath();
    ctx.moveTo(adjusted_source_x, adjusted_source_y);
    ctx.lineTo(adjusted_target_x, adjusted_target_y);
    ctx.lineWidth = width;
    ctx.strokeStyle = style;
    ctx.stroke();
}

const default_link_style = `rgba(128, 128, 128, 1)`;
//const default_link_style = `rgba(128,,0, 1)`;

const draw_tree_link = function(ctx, source_x, source_y, target_x, target_y, style=default_link_style, width=1, erase_width=4) {
    draw_single_line(ctx, source_x, source_y, source_x, target_y, style, width, erase_width);
    draw_single_line(ctx, source_x, target_y, target_x, target_y, style, width, erase_width);
}


function set_equality(a, b) {
    if (a.size !== b.size) {
        return false;
    }
    for (const e of a) {
        if (!b.has(e)) {
            return false;
        }
    }
    return true;
}


const redraw_full_tree = function () {
    let canvas = document.getElementById("tree-canvas");
    let tree_ctx = canvas.getContext('2d');
    tree_ctx.clearRect(0, 0, canvas.width, canvas.height);
    set_background('tree-canvas');
    tree_links.forEach(t => {
        if (t == current_link || selected_links.includes(t)) {
            draw_tree_link(tree_ctx, t.scaled_coord.source.x, t.scaled_coord.source.y, t.scaled_coord.target.x, t.scaled_coord.target.y, 'purple', 3, 2);
        } else {
            draw_tree_link(tree_ctx, t.scaled_coord.source.x, t.scaled_coord.source.y, t.scaled_coord.target.x, t.scaled_coord.target.y);
        }
    });

    tree_root.leaves().forEach(leaf => {
        tree_ctx.fillStyle = "blue";
        tree_ctx.beginPath();
        tree_ctx.arc(scale_x(leaf.x), scale_y(leaf.y), 5, 0, Math.PI * 2);
        tree_ctx.fill();
        tree_ctx.fillStyle = "black";
        tree_ctx.font = '10px sans-serif';
        tree_ctx.fillText(`${leaf.data.name} ${leaf.data.length.toPrecision(4)}`, scale_x(leaf.x) + 6, scale_y(leaf.y) + 2.5);
    });

    tree_ctx.fillStyle = `rgba(128, 128, 128, .8)`;
    tree_root.descendants().forEach(node => {
        if (node.height > 0) {
            tree_ctx.beginPath();
            tree_ctx.arc(scale_x(node.x), scale_y(node.y), 5, 0, Math.PI * 2);
            tree_ctx.fill();
        }
    });

}

/*
 * WAGNERR: There is redundancy between this and create_tree in phylogram.js
 */
const create_mapped_tree = function (data, plot_div, width, height, tree_number) {


    let canvas = document.createElement('canvas');

    [scale_x, scale_y, tree_root] = get_root(data, height, width);

    canvas.setAttribute('id', 'tree-canvas')

    canvas.setAttribute("width", width);
    canvas.setAttribute("height", height);

    if (tree_number) {
        document.getElementById(`${plot_div}`).append(htmlToElement(`<div><h3>Tree ${tree_number}</h3></div>`));
    }

    document.getElementById(`${plot_div}`).append(canvas);
    let ctx = canvas.getContext('2d');

    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, width, height);

    ctx.lineWidth = 1.5;
    selected_links = [];
    tree_links = [];
    tree_root.links().forEach(link => {
        let scaled_link = {
                "source": {
                        "x": scale_x(link.source.x),
                        "y": scale_y(link.source.y)
                    },
                "target": {
                        "x": scale_x(link.target.x),
                        "y": scale_y(link.target.y)
                    }
            }


        tree_links.push({'link': link, 'scaled_coord': scaled_link});
    });

    // tree_links.forEach(t => {
    //    draw_tree_link(ctx, t.scaled_coord.source.x, t.scaled_coord.source.y, t.scaled_coord.target.x, t.scaled_coord.target.y);
    // });


    canvas.addEventListener("mousemove", function(e) {
        let event_date = Date.now()

        // if (current_link !== null) {
        //     draw_single_line(ctx, current_link.scaled_coord.source.x, current_link.scaled_coord.source.y, current_link.scaled_coord.source.x, current_link.scaled_coord.target.y, default_link_style, 1, 4);
        //     draw_single_line(ctx, current_link.scaled_coord.source.x, current_link.scaled_coord.target.y, current_link.scaled_coord.target.x, current_link.scaled_coord.target.y, default_link_style, 1, 4);
        //     document.getElementById('bipartition-number').innerHTML = "";
        // }

        //let x = e.pageX - canvas_rect.left, y = e.pageY - canvas_rect.top;
        let canvas_rect = canvas.getBoundingClientRect();
        let x = e.clientX- canvas_rect.left, y = e.clientY- canvas_rect.top;
        //let x = e.pageX, y = e.pageY;
        let found_link = null;
        for (const t of tree_links) {
           let on_link = false;

           create_empty_line(ctx, t.scaled_coord.source.x, t.scaled_coord.source.y, t.scaled_coord.source.x, t.scaled_coord.target.y);
           if (ctx.isPointInStroke(x, y) && t.link.target.children !== undefined) {
               on_link = true;
           }

           create_empty_line(ctx, t.scaled_coord.source.x, t.scaled_coord.target.y, t.scaled_coord.target.x, t.scaled_coord.target.y);
           if (ctx.isPointInStroke(x, y) && t.link.target.children !== undefined) {
               on_link = true;
           }

           if (on_link) {
                // draw_single_line(ctx, t.scaled_coord.source.x, t.scaled_coord.source.y, t.scaled_coord.source.x, t.scaled_coord.target.y, 'purple', 2, 2);
                // draw_single_line(ctx, t.scaled_coord.source.x, t.scaled_coord.target.y, t.scaled_coord.target.x, t.scaled_coord.target.y, 'purple', 2, 2);
                let leaf_names = [];
                for (const leaf of t.link.target.leaves()) {
                    leaf_names.push(leaf.data.name);
                }
                let leaves_set = new Set(leaf_names);
                for (const [bipartition_num, bipartition_leaves] of Object.entries(parsed_bipartition_taxa)) {
                    let bipartition_set = new Set(bipartition_leaves);
                    if (set_equality(leaves_set, bipartition_set)) {
                        //document.getElementById('bipartition-number').innerHTML = bipartition_num;
                        current_bipartition = bipartition_num;
                    }
                }
                found_link = t;
                break;
           }
        }
        if (found_link !== null) {
            if (current_link !== found_link) {
                current_link = found_link;
            }
            redraw_full_cov_graph();
            redraw_full_tree();
            if (current_bipartition !== null) {
                tooltip = {
                    ctx: ctx,
                    x: x,
                    y: y,
                    text: `Bipartition ${current_bipartition}`
                };
                draw_tooltip();
            }
        } else {
            tooltip = null;
            if (current_link !== null) {
                current_link = null;
                current_bipartition = null;
                redraw_full_cov_graph();
                redraw_full_tree();
            }
        }
    });

    canvas.addEventListener("click", function(e) {
        if (current_link != null) {
            if (!selected_links.includes(current_link)){
                if (e.shiftKey) {
                    selected_links.push(current_link);
                    if (current_bipartition != null) {
                        selected_bipartitions.push(current_bipartition);
                    }
                } else {
                    selected_links = [current_link];
                    if (current_bipartition != null) {
                        selected_bipartitions = [current_bipartition];
                    }
                }
            } else {
                selected_links = selected_links.filter(b => b != current_link);
                if (current_bipartition != null) {
                    selected_bipartitions = selected_bipartitions.filter(b => b != current_bipartition);
                }
            }
        }
    });

    redraw_full_tree();
}

const event_plot_for_tree = function (e) {
    let tree_data = e.tree;

    create_mapped_tree(tree_data, e.plot_div, e.width, e.height, e.tree_num);
}

function draw_tree(data) {
    const doc_width = document.getElementById("tree-plot").clientWidth;
    const tree_plot_width = Math.floor((doc_width - (.15 * doc_width)) / 100) * 100;
    let tn = Number(document.getElementById("boottree-slider").value);
    document.getElementById("boottree-number").textContent = tn;
    removeChildNodes("tree-plot");
    let pn = newick_parse(data[tn - 1]);
    // Mock up
    event_plot_for_tree({
        tree: pn,
        tree_num: tn,
        width: tree_plot_width,
        height: tree_plot_width,
        plot_div: "tree-plot"
    });
}

function draw_covariance() {
    //cleanExistingPlot();
    removeChildNodes("cov-plot");
    let doc_width = document.getElementById("cov-plot").clientWidth;
    let div_width = Math.floor((doc_width - (.15 * doc_width)) / 100) * 100;
    let div_height = div_width;
    let canvas_elm = htmlToElement(`<canvas id="topo-network" width="${div_width}" height="${div_height}">`);
    document.getElementById("cov-plot").append(canvas_elm);

    draw_graph();
    update_links({
        link_threshold: 50
    });
}

function draw_all(data) {
    draw_tree(data);
    draw_covariance();
}

/*
 * Redundant with animate in hierarchy plotting.
 */
const animate = function (data) {
    const control_div = document.getElementById("plot-controls");
    //control_div.classList.add("box");
    control_div.append(htmlToElement(`
    <div class="field"><div class="control"><label for="boottree-slider">Tree Number: <span id="boottree-number">1</span></label>
    <input type="range" id="boottree-slider" name="boottree"
    min="1" max="${data.length - 1}" step="1" value="1" style="width: 60em;">
        </div></div>`));
//    <div>Bipartition Number: <span id="bipartition-number"></span></div>

    draw_tree(data);

    document.getElementById("boottree-slider").addEventListener("input", () => {
        draw_tree(data);
    });
}

const covariance_plot_init = function (init_obj) {
    let { guid_fn } = init_obj;
    const my_guid = guid_fn();


    addEventListener("BipartitionFiles", e => {
        //let cov_matrix_file_obj = e.detail.files.filter(obj => RegExp(/Covariance Matrix/).test(obj.name));
        let cov_matrix_file_obj = e.detail.files.filter(obj => obj.name == e.detail.selected_file);
        let history_item_string = cov_matrix_file_obj[0].name.match(/data [0-9]+$/)[0];
        let history_number = parseInt(history_item_string.match(/[0-9]+/));

        let bip_matrix_regex = new RegExp(`Bipartition Matrix.*${history_item_string}$`);
        let bip_matrix_file_obj = e.detail.files.filter(obj => bip_matrix_regex.test(obj.name));

        let bip_counts_regex = new RegExp(`Bipartition Counts.*${history_item_string}$`);
        let bip_counts_file_obj= e.detail.files.filter(obj => bip_counts_regex.test(obj.name));

        let taxa_ids_regex = new RegExp(`Taxa IDs.*${history_item_string}$`);
        let taxa_ids_file_obj = e.detail.files.filter(obj => taxa_ids_regex.test(obj.name));

        let trees_file_obj = e.detail.files.filter(obj => obj.hid == history_number);

        dispatchEvent(build_event("FileContentsRequest", {
            guid: my_guid,
            files: [cov_matrix_file_obj.pop().dataset_id, bip_matrix_file_obj.pop().dataset_id, taxa_ids_file_obj.pop().dataset_id, bip_counts_file_obj.pop().dataset_id, trees_file_obj.pop().dataset_id]
        }));
    });

    //User has requested that CD groups be used in plotting.
    addEventListener("UseCDGroupsTrue", e => {
        if (e.detail.type === "Cova") {
            parse_cd(e.detail.groups);
        }
    });
    //User has requested that CD groups _not_ be used in plotting.
    addEventListener("UseCDGroupsFalse", e => {
        cd_groups = undefined;
    });

    addEventListener("FileContents", e => {
        if (e.detail.guid === my_guid) {
            graph_data = {
                "nodes": [],
                "displayed_links": [],
                "all_links": []
            };
            max_covariance = 0;

            e.detail.contents.forEach(file => {
                if (/^Covariance Matrix/.test(file.fileName)) {
                    let arr = file.data.split('\n');
                    parse_covariance(clean_data(file.data));
                }
                if (/^Bipartition Matrix/.test(file.fileName)) {
                    parse_bipartition_cov(clean_data(file.data));
                }
                if (/^Taxa IDs/.test(file.fileName)) {
                    let arr = file.data.split('\n')
                    arr.pop();
                    arr.shift();
                    arr.forEach(e => {
                        taxa_array.push(e.split(',')[1].trim());
                    });
                }
                if (/^Bipartition Counts/.test(file.fileName)) {
                    parsed_bipartition_taxa = parse_taxa_partitions(clean_data(file.data), taxa_array);

                }
                if (/cloudforest.trees/.test(file.fileExt)) {
                    boottree_data = file.data.split(';');
                }
            });

            if (!document.getElementById("tree-plot")) {
                document.getElementById("plot").append(htmlToElement(`<div id="tree-plot" style="vertical-align: top; width: 50%; margin: 0px; padding-right: 0px; font-size:0; border: 0px; display:inline-block; overflow: visible"/>`));
            }
            if (!document.getElementById("cov-plot")) {
                document.getElementById("plot").append(htmlToElement(`<div id="cov-plot" style="width: 50%; margin: 0px; padding-left: 0px; border: 0px; font-size:0; display:inline-block; overflow: visible"/>`));
            }
            draw_covariance();

            removeChildNodes("plot-controls");
            removeChildNodes("plot-metadata");
            build_link_edit_ui();
            animate(boottree_data); //data string of trees into an array.
            //build_dom();
            //update_graph({
            //    link_threshold: 50
            //});
        }
    });

    addEventListener("CovariancePlotRequest", e => {
        dispatchEvent(build_event("RequestBipartitionFile", {guid: my_guid, selected_file: e.detail.file_name}));
    });

}

export { covariance_plot_init }
