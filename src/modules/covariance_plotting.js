import { scaleQuantize } from "d3-scale";
import { forceSimulation, forceCollide, forceManyBody, forceLink, forceX, forceY } from "d3-force";
import { select, event } from "d3-selection";
import { drag } from "d3-drag";
import { mean, max } from "d3-array";

import { roundedRect } from "./support_funcs";
import { cleanExistingPlot, htmlToElement } from "./html_templates";
import { css_colors } from "./colors";

const getEvent = () => event; // This is necessary when using webpack >> https://github.com/d3/d3-zoom/issues/32
const d3 = Object.assign(
    {
        mean,
        max,
        select,
        event,
        getEvent,
        scaleQuantize,
        forceSimulation, forceCollide, forceManyBody, forceLink, forceX, forceY,
        drag
    }
);


let event_build_fn = undefined;
let graph_data = undefined;
let filtered_adjacency_list = undefined;
let bipartition_file = undefined;
let cd_groups = undefined;
let max_covariance = 0;
let num_trees = 0;

const FILE_NAME_REGEX = /^Covariance Matrix/;

const parse_cd = function (groups) {
    let d = {};
    let hsl_colors = Object.keys(groups).map((v, i) => {
        return css_colors[i];
    });

    Object.keys(groups).forEach((k, idx) => {
        groups[k].forEach(bp => {
            d[bp] = { group: k, color: hsl_colors[idx] };
        });
    });
    cd_groups = d;
}

const parse_covariance = function (m) {
    m.forEach((arr, idx) => {
        //Removing superflous empty value at end of each array
        arr.filter(v => v.length > 1).forEach((val, i) => {
            if (i != idx) {
                let o = {
                    "source": String(idx),
                    "target": String(i),
                    "value": Number(val.trim())
                }
                graph_data.links.push(o);
                if (Math.abs((Number(val.trim()))) > max_covariance) {
                    max_covariance = Math.abs(Number(val.trim()));
                }
            }
        });
    });
}

/**
 * Parses the TreeScaper bipartition matrix producing a BP -> tree object.
 * Key: bipartition number; Value: array of trees where the bipartition is present.
 * @param {[]} m - Bipartition Matrix generated by TreeScaper
 */
const parse_bipartition = function (m) {
    let b = {};
    m.forEach(r => {
        let bp_name = String(Number(r[0].trim()) + 1);
        if (!(bp_name in b)) {
            b[bp_name] = [];
        }
        b[bp_name].push(r[1]);
    });

    Object.keys(b).forEach(k => {
        let o = {
            "id": k,
            "num_trees": b[k].length
        };
        graph_data.nodes.push(o);
        if (b[k].length > num_trees) {
            num_trees = b[k].length;
        }
    });
}

/**
     * Return a profile for the requested node, including
     * link information
     * @param {*} node
     */
const profile_node = function (node) {
    let r_val = {
        "id": node.id,
        "num_trees": node.num_trees
    };
    let pos_values = [];
    let neg_values = [];
    graph_data.links.forEach(l => {
        if (l.source === node.id || l.target === node.id) {
            if (l.value < 0) {
                neg_values.push(l.value);
            }
            if (l.value >= 0) {
                pos_values.push(l.value);
            }
        }
    });
    r_val["num_pos_cova"] = pos_values.length;// || NaN;
    r_val["num_neg_cova"] = neg_values.length;// || NaN;
    r_val["mean_pos_cova"] = d3.mean(pos_values);// || NaN;
    r_val["mean_neg_cova"] = d3.mean(neg_values) || NaN;
    r_val["max_neg_cova"] = -1 * d3.max(neg_values.map(v => Math.abs(v))) || NaN;
    r_val["max_pos_cova"] = d3.max(pos_values);// || NaN;
    return r_val;
}

const draw_profile_legend = function (p) {
    const elm = document.getElementById("plot-metadata");
    elm.classList.add("box");
    let e_string = `
    <h4>Partition ${p.id}</h4>
    <table class="table"><thead><tr>
    <th>Tree Count</th><th># Pos. Cova</th><th>Mean Pos. Cova</th><th>Max Pos. Cova</th>
    <th># Neg. Cova</th><th>Mean Neg. Cova</th><th>Max Neg. Cova</th></tr></thead>
    <tbody>
    <td>${p.num_trees}</td><td>${p.num_pos_cova}</td><td>${p.mean_pos_cova.toPrecision(4)}</td><td>${p.max_pos_cova.toPrecision(4)}</td>
    <td>${p.num_neg_cova}</td><td>${p.mean_neg_cova.toPrecision(4)}</td><td>${p.max_neg_cova.toPrecision(4)}</td>
    </tbody>
    </table>
    `
    elm.innerHTML = e_string;
}

//Set background so saved PNG has a background color.
const set_c_background = function() {
    let canvas = document.getElementById("topo-network");
    let ctx = undefined;
    if (canvas != null) {
        ctx = canvas.getContext('2d');        
        ctx.globalCompositeOperation = 'destination-over'
        ctx.fillStyle = "white";
        ctx.globalAlpha = 1.0;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
}

const draw_graph = function (graph_data) {

    const link_scale = d3.scaleQuantize()
        .domain([0, max_covariance])
        .range([.5, 2, 5, 10]);

    let canvas = document.getElementById("topo-network"),
        ctx = canvas.getContext('2d'),
        width = canvas.getAttribute("width"),
        height = canvas.getAttribute("height"),
        r = 10;

    let tick = function () {
        ctx.clearRect(0, 0, width, height);

        ctx.globalAlpha = 0.2;
        graph_data.links.forEach(drawLink);

        graph_data.nodes.forEach(drawNode);
    }

    const set_alpha = function (d) {
        let alpha_pct = (d.num_trees / num_trees);
        if (alpha_pct < 0.1) { alpha_pct = 0.1 };
        if (cd_groups) {
            return 1.0;
        } else {
            return alpha_pct;
        }
    }

    const set_fillstyle = function (d) {
        if (cd_groups) {
            try {
                let x = cd_groups[Number(d.id)].color;
                return x;
            } catch (error) {
                return "white";
            }
        } else {
            return "black";
        }
    }

    let drawNode = function (d) {
        ctx.beginPath();
        ctx.moveTo(d.x, d.y);
        ctx.arc(d.x, d.y, r, 0, Math.PI * 2);
        ctx.globalAlpha = set_alpha(d);
        ctx.fillStyle = set_fillstyle(d);
        ctx.fill();
    }


    let drawLink = function (l) {
        ctx.beginPath();
        if (l.value < 0) {
            ctx.strokeStyle = "red";
        } else if (l.value > 0) {
            ctx.strokeStyle = "blue";
        } else {
            ctx.strokeStyle = "lime";
            ctx.lineDashOffset = 1;
        }
        ctx.lineWidth = link_scale(Math.abs(l.value));
        ctx.moveTo(l.source.x, l.source.y);
        ctx.lineTo(l.target.x, l.target.y);
        ctx.stroke();

    }

    let simulation = d3.forceSimulation(graph_data.nodes)
        .force("x", d3.forceX(width / 2))
        .force("y", d3.forceY(height / 2))
        .force("charge", d3.forceManyBody().strength(-20))
        .force("link", d3.forceLink()
            .id(function (d) { return d.id; }).distance(width / 3));

    simulation.on("tick", () => {
        tick();
        set_c_background();
    });
    simulation.force("link")
        .links(graph_data.links);

    let dragstarted = function () {
        if (!d3.getEvent().active) simulation.alphaTarget(0.3).restart();
        d3.getEvent().subject.fx = d3.getEvent().subject.x;
        d3.getEvent().subject.fy = d3.getEvent().subject.y;
    }

    let dragged = function () {
        d3.getEvent().subject.fx = d3.getEvent().x;
        d3.getEvent().subject.fy = d3.getEvent().y;
    }

    let dragended = async function () {
        if (!d3.getEvent().active) simulation.alphaTarget(0);
        d3.getEvent().subject.fx = null;
        d3.getEvent().subject.fy = null;
        let p = profile_node(d3.getEvent().subject);
        draw_profile_legend(p);
        ctx.beginPath();
        ctx.fillStyle = "black";
        ctx.globalAlpha = 0.5;
        roundedRect(ctx, d3.getEvent().subject.x - 10, d3.getEvent().subject.y - 30, 250, 50, 5);
        ctx.globalAlpha = 1.0;
        ctx.fillStyle = "white";
        ctx.font = "bold 15px Arial";
        ctx.fillText(`Partition ${p.id} - Trees: ${p.num_trees} `, d3.getEvent().subject.x, d3.getEvent().subject.y, 200);
        simulation.stop();
        await new Promise(r => setTimeout(r, 1000));
        simulation.restart();
    }

    let dragsubject = function () {
        return simulation.find(d3.getEvent().x, d3.getEvent().y);
    }

    d3.select(canvas)
        .call(d3.drag()
            .container(canvas)
            .subject(dragsubject)
            .on("start", dragstarted)
            .on("drag", dragged)
            .on("end", dragended));

}

const build_dom = function () {
    cleanExistingPlot();
    let doc_width = document.getElementById("plot").clientWidth;
    let div_width = Math.floor((doc_width - (.15 * doc_width)) / 100) * 100;
    let div_height = div_width / 2;

    let canvas_elm = htmlToElement(`<canvas id="topo-network" width="${div_width}" height="${div_height}">`);
    document.getElementById("plot").append(canvas_elm);
    build_link_edit_ui();
}

const build_matrix = function (graph_data) {
    filtered_adjacency_list = {}; //Matrix as adjacency list
    graph_data.nodes.forEach(n => {
        filtered_adjacency_list[n.id] = [];
    });
    graph_data.links.forEach(l => {
        filtered_adjacency_list[l.source.id].push({ id: l.target.id, covariance: l.value });
    });
}

const update_graph = function (conf_update) {
    let link_strength_thresh = conf_update.link_threshold / 100.0;
    //edit the links
    let edited_links = [];
    graph_data.links.forEach(obj => {
        if (Math.abs(obj.value) >= (link_strength_thresh * max_covariance)) {
            edited_links.push(obj);
        }
    });
    draw_graph({
        nodes: graph_data.nodes,
        links: edited_links
    });

    build_matrix({
        nodes: graph_data.nodes,
        links: edited_links
    });
    document.getElementById("publish-graph").disabled = false;
}

const build_link_edit_ui = function () {
    let pcc = document.getElementById("plot-controls");
    pcc.classList.add("box");
    pcc.append(htmlToElement(`<div class="field has-addons">
        <h4>Remove Links Below X% of Maximum Magnitude</h4>
        <div class="control">
            <input type="number" id="link-strength" min="1" max="100" value="50" size="4"></input>
        </div >
        <div class="control">
            <a id="btn-links-reset" class="button is-info">Reset</a>
        </div>
        </div > `));

    pcc.append(htmlToElement(`<div class="field has-addons">
    <h4>Publish Filtered Graph</h4>
    <div class="control">
        <button id="publish-graph" class="button is-info">Publish</button>
    </div>`));

    document.getElementById("publish-graph").disabled = true;

    document.getElementById("link-strength").addEventListener("input", event => {
        let thresh = Number(document.getElementById("link-strength").value);
        update_graph({
            link_threshold: thresh
        });
    });

    document.getElementById("btn-links-reset").addEventListener("click", event => {
        update_graph({
            link_threshold: 50
        });
        document.getElementById("link-strength").value = 50;
        document.getElementById("publish-graph").disabled = true;
    });

    document.getElementById("publish-graph").addEventListener("click", () => {
        dispatchEvent(event_build_fn("PublishData", {
            data: filtered_adjacency_list,
            file_name: `Filtered Adjacency at ${document.getElementById("link-strength").value}`
        }));
    });
}

//REFACTOR THIS TO ONE MODULE
const clean_data = function(data) {
    let t_arr = data.split('\n');
    let arr = []
    t_arr.forEach(d => {
        if (d.length > 0) {
            arr.push(d.split('\t')); 
        }
    });
    return arr;
}

const covariance_plot_init = function (init_obj) {
    let { guid_fn, event_fn } = init_obj;
    event_build_fn = event_fn;
    const my_guid = guid_fn();


    addEventListener("BipartitionFiles", e => {
        //Only want the matrix file, not the log file.
        let files = e.detail.files.filter(obj => RegExp(/[Bb]ipartition [Mm]atrix/).test(obj.name));
        bipartition_file = files[0];
    });
    dispatchEvent(event_build_fn("RequestBipartitionFile", {guid: my_guid}));

    //User has requested that CD groups be used in plotting.
    addEventListener("UseCDGroupsTrue", e => {
        if (e.detail.type === "Cova") {
            console.log("Using CD for bipartition graphing.");
            parse_cd(e.detail.groups);
        }
    });
    //User has requested that CD groups _not_ be used in plotting.
    addEventListener("UseCDGroupsFalse", e => {
        cd_groups = undefined;
    });

    addEventListener("FileContents", e => {
        if (e.detail.guid === my_guid) {
            graph_data = {
                "nodes": [],
                "links": []
            };

            e.detail.contents.forEach(file => {
                if (/^Covariance Matrix/.test(file.fileName)) {
                    let arr = file.data.split('\n');
                    parse_covariance(clean_data(file.data));
                }
                if (/^Bipartition Matrix/.test(file.fileName)) {
                    parse_bipartition(clean_data(file.data));
                }
            });
            build_dom();
            update_graph({
                link_threshold: 50
            });
        }
    });

    addEventListener("TreePlotRequest", e => {
        if (FILE_NAME_REGEX.test(e.detail.file_name)) {
            dispatchEvent(event_build_fn("FileContentsRequest", {
                guid: my_guid,
                files: [e.detail.file_id, bipartition_file.id]
            }));
        }
    });

}

export { covariance_plot_init }