/**
 * Manage TreeScaper bipartition parsing and data requests.
 */
import { build_event } from "./support_funcs";

let bipartition_files = { matrix: undefined, counts: undefined, taxa: undefined };
let trees_by_partition = undefined;
let partition_taxa = undefined;
/**
* Parses the TreeScaper bipartition matrix producing a BP -> tree object.
* Key: bipartition number; Value: array of trees where the bipartition is present.
*
* @param {[]} m - Bipartition Matrix generated by TreeScaper
*/
const parse_bipartition = function (m) {
    let b = {};
    m.forEach(r => {
        let bp_name = String(Number(r[0].trim()) + 1);
        if (!(bp_name in b)) {
            b[bp_name] = [];
        }
        b[bp_name].push(Number(r[1] + 1));
    });
    return b;
}
/**
 * Parse the bipartion count file
 *
 *  0, 000000000000000010011000000, 11
    1, 001111111111000000000100000, 10
    2, 001100001111111111111011110, 1
    3, 000011111111111100000011110, 1
 *
 * @param {*} m - bipartition count file. An array of strings
 */
const parse_taxa_partitions = function (m, taxa_array) {
    let part_taxa = {};
    m.forEach(line => {
        let arr = line[0].split(' ');
        let bp = Number(arr[0]) + 1;
        part_taxa[bp] = [];
        arr[1].trim().split("").forEach((e, idx) => {
            if (e === "1") {
                part_taxa[bp].push(taxa_array[idx]);
            }
        });
    });
    return part_taxa;
}

const bipartions_for_tree = function (tree_num) {
    let target = Number(tree_num);
    let bipartitions = []
    let taxa = {};
    Object.keys(trees_by_partition).forEach(key => {
        if (trees_by_partition[key].indexOf(target) > -1) {
            bipartitions.push(key);
            taxa[key] = part_taxa[key];
        }
    });
    dispatchEvent(build_event("BipartitionsForTree", {
        partitions: bipartitions,
        taxa: taxa
    }));
}

//REFACTOR THIS TO ONE MODULE
const clean_data = function(data) {
    let t_arr = data.split('\n');
    let arr = []
    t_arr.forEach(d => {
        if (d.length > 0) {
            arr.push(d.split('\t'));
        }
    });
    return arr;
}

export {
    parse_taxa_partitions }
